[{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/3-item-types/full-item/","title":"FullItem","tags":[],"description":"","content":"Full Item //TODO "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/1-getting-started/","title":"Getting Started","tags":[],"description":"","content":"The quickest way to get started using the Microsoft.Azure.CosmosRepository package is to use the AddCosmosRepository extension method on the IServiceCollection interface. This extension method will register the necessary services and configure the repository SDK for you.\n  Create an Azure Cosmos DB SQL resource.\n  Obtain the resource connection string from the Keys blade, be sure to get a connection string and not the key - these are different. The connection string is a compound key and endpoint URL.\n  Call AddCosmosRepository:\npublic void ConfigureServices(IServiceCollection services) { services.AddCosmosRepository(); } The optional setupAction allows consumers to manually configure the RepositoryOptions object:\npublic void ConfigureServices(IServiceCollection services) { services.AddCosmosRepository( options =\u0026gt; { options.CosmosConnectionString = \u0026#34;\u0026lt; connection string \u0026gt;\u0026#34;; options.ContainerId = \u0026#34;data-store\u0026#34;; options.DatabaseId = \u0026#34;samples\u0026#34;; }); }   Define your object graph, objects must inherit Item, for example:\nusing Microsoft.Azure.CosmosRepository; public class Person : Item { public string FirstName { get; set; } public string LastName { get; set; } }   Ask for an instance of IRepository\u0026lt;TItem\u0026gt;, in this case the TItem is Person:\nusing Microsoft.Azure.CosmosRepository; public class Consumer { readonly IRepository\u0026lt;Person\u0026gt; _repository; public Consumer(IRepository\u0026lt;Person\u0026gt; repository) =\u0026gt; _repository = repository; // Use the repo... }   Perform any of the operations on the _repository instance, create Person records, update them, read them, or delete.\n  Enjoy!\n  Configuration When OptimizeBandwidth is true (its default value), the repository SDK reduces networking and CPU load by not sending the resource back over the network and serializing it to the client. This is specific to writes, such as create, update, and delete. For more information, see Optimizing bandwidth in the Azure Cosmos DB .NET SDK.\nThere is much debate with how to structure your database and corresponding containers. Many developers with relational database design experience might prefer to have a single container per item type, while others understand that Azure Cosmos DB will handle things correctly regardless. By default, the ContainerPerItemType option is false and all items are persisted into the same container. However, when it is true, each distinct subclass of Item gets its own container named by the class itself.\nWell-known keys Depending on the .NET configuration provider your app is using, there are several well-known keys that map to the repository options that configure your usage of the repository SDK. When using environment variables, such as those in Azure App Service configuration or Azure Key Vault secrets, the following keys map to the RepositoryOptions instance:\n   Key Data type Default value     RepositoryOptions__CosmosConnectionString string null   RepositoryOptions__AccountEndpoint string null   RepositoryOptions__DatabaseId string \u0026quot;database\u0026quot;   RepositoryOptions__ContainerId string \u0026quot;container\u0026quot;   RepositoryOptions__OptimizeBandwidth boolean true   RepositoryOptions__ContainerPerItemType boolean false   RepositoryOptions__AllowBulkExecution boolean false   RepositoryOptionsSerializationOptionsIgnoreNullValues boolean false   RepositoryOptionsSerializationOptionsIndented boolean false   RepositoryOptionsSerializationOptionsPropertyNamingPolicy CosmosPropertyNamingPolicy CosmosPropertyNamingPolicy.CamelCase    Example appsettings.json { \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;RepositoryOptions\u0026#34;: { \u0026#34;CosmosConnectionString\u0026#34;: \u0026#34;\u0026lt;Your-CosmosDB-ConnectionString\u0026gt;\u0026#34;, \u0026#34;AccountEndpoint\u0026#34;: \u0026#34;\u0026lt;Your-CosmosDB-URI\u0026gt;\u0026#34; \u0026#34;DatabaseId\u0026#34;: \u0026#34;\u0026lt;Your-CosmosDB-DatabaseName\u0026gt;\u0026#34;, \u0026#34;ContainerId\u0026#34;: \u0026#34;\u0026lt;Your-CosmosDB-ContainerName\u0026gt;\u0026#34;, \u0026#34;OptimizeBandwidth\u0026#34;: true, \u0026#34;ContainerPerItemType\u0026#34;: true, \u0026#34;AllowBulkExecution\u0026#34;: true, \u0026#34;SerializationOptions\u0026#34;: { \u0026#34;IgnoreNullValues\u0026#34;: true, \u0026#34;PropertyNamingPolicy\u0026#34;: \u0026#34;CamelCase\u0026#34; } } } For more information, see JSON configuration provider.\nExample appsettings.json with Azure Functions { \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Values\u0026#34;: { \u0026#34;RepositoryOptions:CosmosConnectionString\u0026#34;: \u0026#34;\u0026lt;Your-CosmosDB-ConnectionString\u0026gt;\u0026#34;, \u0026#34;RepositoryOptions:AccountEndpoint\u0026#34;: \u0026#34;\u0026lt;Your-CosmosDB-URI\u0026gt;\u0026#34;, \u0026#34;RepositoryOptions:DatabaseId\u0026#34;: \u0026#34;\u0026lt;Your-CosmosDB-DatabaseName\u0026gt;\u0026#34;, \u0026#34;RepositoryOptions:ContainerId\u0026#34;: \u0026#34;\u0026lt;Your-CosmosDB-ContainerName\u0026gt;\u0026#34;, \u0026#34;RepositoryOptions:OptimizeBandwidth\u0026#34;: true, \u0026#34;RepositoryOptions:ContainerPerItemType\u0026#34;: true, \u0026#34;RepositoryOptions:AllowBulkExecution\u0026#34;: true, \u0026#34;RepositoryOptions:SerializationOptions:IgnoreNullValues\u0026#34;: true, \u0026#34;RepositoryOptions:SerializationOptions:PropertyNamingPolicy\u0026#34;: \u0026#34;CamelCase\u0026#34; } } Advanced partitioning strategy As a consumer of Azure Cosmos DB, you can choose how to partition your data. By default, this repository SDK will partition items using their Item.Id value as the /id partition in the storage container. However, you can override this default behavior by:\n Declaratively specifying the partition key path with PartitionKeyPathAttribute Override the Item.GetPartitionKeyValue() method Ensure the the property value of the composite or synthetic key is serialized to match the partition key path Set RepositoryOptions__ContainerPerItemType to true, to ensure that your item with explicit partitioning is correctly maintained  As an example, considering the following:\nusing Microsoft.Azure.CosmosRepository; using Microsoft.Azure.CosmosRepository.Attributes; using Newtonsoft.Json; using System; namespace Example { [PartitionKeyPath(\u0026#34;/synthetic\u0026#34;)] public class Person : Item { public string FirstName { get; set; } = null!; public string? MiddleName { get; set; } public string LastName { get; set; } = null!; [JsonProperty(\u0026#34;synthetic\u0026#34;)] public string SyntheticPartitionKey =\u0026gt; $\u0026#34;{FirstName}-{LastName}\u0026#34;; // Also known as a \u0026#34;composite key\u0026#34;.  protected override string GetPartitionKeyValue() =\u0026gt; SyntheticPartitionKey; } } "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/6-miscellaneous/logging/","title":"Logging","tags":[],"description":"","content":"The Azure Cosmos Repository follows the high performance logging guidelines making use of LoggerMessage throughout the library.\nThis page details what logs we offer and also what EventId ranges we have chosen to use.\nEvent ID Ranges Since this library is making use of EventId\u0026rsquo;s each message we log falls within a range. We have split this range based on the common logging levels you would be use to seeing in any normal applications using ILogger. See the ranges below.\n   Log Level EventId range     Debug/Verbose 15000 - 15100   Information 15101 - 15200   Critical 15401 - 15500   Warning 15201 - 15300   Error 15301 - 15400     You can also consult the code for more information EventIds definitions\n "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/1-getting-started/partioning/","title":"Partitioning","tags":[],"description":"","content":"Partitioning is a huge part of Cosmos DB. There are many different strategies you may want to take. Such as, splitting different types of item\u0026rsquo;s across containers, sharing some IItem\u0026rsquo;s in one container and not others and finally, in some cases, even putting all IItem types in a single container.\nDefault Strategy Adding the Azure Cosmos Repository with no real configuration, like below. Will result in a simple strategy being assumed on your behalf. This will leave the option\u0026rsquo;s configured in there default state. This means a property called ContainerPerItemType is set to false. This means that the Azure Cosmos Repository will store all IItem\u0026rsquo;s in the same container, setting all the IItem\u0026rsquo;s within to use the partition key /id.\nusing Microsoft.Azure.CosmosRepository; var builder = WebApplication.CreateBuilder(args); builder.Services.AddCosmosRepository(); var app = builder.Build(); app.MapGet(\u0026#34;/\u0026#34;, () =\u0026gt; \u0026#34;Default Cosmos Repository Partitioning Strategy\u0026#34;); app.Run(); The default partitioning strategy is simple, all IItem\u0026rsquo;s will be in a single logical partition split by there unique IDs. Which default to a GUID. This in small applications is often ample. A simple rule of thumb for whether or not this would be okay for you would be, do you see yourself spanning over a physical partition? If no then this option could be the way to go. However, in any scenarios where you are making an application that may grow in size, complexity or scale. It may be best to look at taking a bit more control over your partitioning strategy.\n This strategy is also demonstrated in the WebTier sample application.\n Taking Control The next configuration allows you to take more control over the partitioning strategy. The first thing to do is to set the ContainerPerItemType equal to true. This can be done like in the example below. Once this field has been set, then you need to define which container each IItem should be placed into and also what partition key it should use. There are currently 2 methods to do this in the Azure Cosmos Repository.\nusing Microsoft.Azure.CosmosRepository; var builder = WebApplication.CreateBuilder(args); builder.Services.AddCosmosRepository(options =\u0026gt; { options.ContainerPerItemType = true; }); var app = builder.Build(); app.MapGet(\u0026#34;/\u0026#34;, () =\u0026gt; \u0026#34;Custom Cosmos Repository Partitioning Strategy\u0026#34;); app.Run(); The IItem Container Builder The first option that you have to configure IItem\u0026rsquo;s container options is to use the IItemContainerBuilder which you can access via the RepositoryOptions. See the examples below.\nCustomer Order System Example In the below example we have two IItem types defined. One is the Customer item which is configured to be stored in the customers container, partitioned by /emailAddress. The second is the Order item, partitioned by /customerId.\nusing Microsoft.Azure.CosmosRepository; var builder = WebApplication.CreateBuilder(args); builder.Services.AddCosmosRepository(options =\u0026gt; { options.ContainerPerItemType = true; options.ContainerBuilder.Configure\u0026lt;Customer\u0026gt;(userContainerOptions =\u0026gt; { userContainerOptions.WithContainer(\u0026#34;customer\u0026#34;); userContainerOptions.WithPartitionKey(\u0026#34;/emailAddress\u0026#34;); }); options.ContainerBuilder.Configure\u0026lt;Order\u0026gt;(orderContainerOptions =\u0026gt; { orderContainerOptions.WithContainer(\u0026#34;orders\u0026#34;); orderContainerOptions.WithPartitionKey(\u0026#34;/customerId\u0026#34;); }); }); var app = builder.Build(); app.MapGet(\u0026#34;/\u0026#34;, () =\u0026gt; \u0026#34;Sample e-commerce Partitioning Strategy\u0026#34;); app.Run(); Inventory Example The below example shows how two or more IItem types can share a container and a partitioning strategy. This defines a Stock item that might hold the name, price, size, and maybe weight. This is partitioned by the /stockReferenceNumber. The StockRecord item is a collection of StockRecord\u0026rsquo;s. This record represents when a piece of stock was added or removed from the inventory, when this occurred, and maybe a reason why. This is stored in the same container as the Stock item whose history it is recording. It also shares the same partitioning strategy. In the example below it means that all Stock and its StockRecord\u0026rsquo;s are stored in the same logical partition in Cosmos DB.\nusing Microsoft.Azure.CosmosRepository; var builder = WebApplication.CreateBuilder(args); builder.Services.AddCosmosRepository(options =\u0026gt; { options.ContainerPerItemType = true; options.ContainerBuilder.Configure\u0026lt;Stock\u0026gt;(userContainerOptions =\u0026gt; { userContainerOptions.WithContainer(\u0026#34;stock\u0026#34;); userContainerOptions.WithPartitionKey(\u0026#34;/stockReferenceNumber\u0026#34;); }); options.ContainerBuilder.Configure\u0026lt;StockRecord\u0026gt;(orderContainerOptions =\u0026gt; { orderContainerOptions.WithContainer(\u0026#34;stock\u0026#34;); orderContainerOptions.WithPartitionKey(\u0026#34;/stockReferenceNumber\u0026#34;); }); }); var app = builder.Build(); app.MapGet(\u0026#34;/\u0026#34;, () =\u0026gt; \u0026#34;Sample Inventory Partitioning Strategy\u0026#34;); app.Run(); Attribute usage Another option to configure a partitioning strategy is to use attributes to decorate your IItem types. See the examples below.\nCustomer Partitioning Strategy The example below show\u0026rsquo;s how you can achieve a custom partitioning strategy using attributes.\nusing Microsoft.Azure.CosmosRepository.Attributes; using Microsoft.Azure.CosmosRepository; [Container(\u0026#34;customers\u0026#34;)] [PartitionKeyPath(\u0026#34;/emailAddress\u0026#34;)] public class Customer : FullItem { public string EmailAddress { get; set; } protected override string GetPartitionKeyValue() =\u0026gt; EmailAddress; }  Note the override of the GetPartitionKeyValue method. This is required to tell the library which property to get your partition key value from.\n "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/4-queries/specification-pattern/","title":"Specification Pattern","tags":[],"description":"","content":"The Azure Cosmos Repository also provides a way to query data based on a set of specifications. These are defined as classes. The inspiration for this implementation was taken from ardalis/Specification on Github. This provides a similar mechanism for entity framework.\nSimple Specification The specification below queries for all products in a category ordered by there price.\npublic class ProductSpecificationExamples { private class ProductsPriceLowestToHighestInCategory : DefaultSpecification\u0026lt;Product\u0026gt; { public ProductsPriceLowestToHighestInCategory(string categoryId) =\u0026gt; Query .Where(x =\u0026gt; x.PartitionKey == categoryId) .OrderBy(x =\u0026gt; x.Price); } public async Task\u0026lt;IQueryResult\u0026lt;Product\u0026gt;\u0026gt; RunDemoAsync(IRepository\u0026lt;Product\u0026gt; repository) { IQueryResult\u0026lt;Product\u0026gt; orderedProducts = await _productsRepository.QueryAsync(new ProductsPriceLowestToHighestInCategory(\u0026#34;Clothing\u0026#34;)); return orderedProducts; } } Specifications - Ordered A specification can also contain more than one ordering clause. You can order by one property then by another.\npublic class ProductSpecificationAdvancedOrderingExamples { private class ProductsPriceLowestToHighestThenByName : DefaultSpecification\u0026lt;Product\u0026gt; { public ProductsPriceLowestToHighestInCategory(string categoryId) =\u0026gt; Query .OrderBy(x =\u0026gt; x.Price) .ThenByDescending(x =\u0026gt; x.Name); } public async Task\u0026lt;IQueryResult\u0026lt;Product\u0026gt;\u0026gt; RunDemoAsync(IRepository\u0026lt;Product\u0026gt; repository) { IQueryResult\u0026lt;Product\u0026gt; orderedProducts = await _productsRepository.QueryAsync(new ProductsPriceLowestToHighestThenByName()); return orderedProducts; } }  If you want to use the .ThenBy or .ThenByDescending methods you will need to add composite index to the fields you are querying on. If not you will get an exception.\n "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/1-getting-started/authentication/","title":"Authentication","tags":[],"description":"","content":"Authenticating using an identity The Azure Cosmos DB .NET SDK also supports authentication using identities, which are considered superior from an audit and granularity of permissions perspective. Authenticating using a connection string essentially provides full access to perform operations within the data plane of your Cosmos DB Account. More information on the Azure control plane and data plane is available here.\nThis library also supports authentication using an identity. To authenticate using an identity (User, Group, Application Registration, or Managed Identity) you will need to set the AccountEndpoint and TokenCredential options that are available on the RepositoryOptions class.\nIn a basic scenario, there are three steps that need to be completed:\n  If the identity that you would like to use, does not exist in Azure Active Directory, create it now.\n  Use the Azure CLI to assign the appropriate role to your identity at the desired scope. - In most cases, using the built-in roles will be sufficient. However, there is support for creating custom role definitions using the Azure CLI, you can read more on this here.\n  Configure your application using the AddCosmosRepository method in your Startup.cs file:\nusing Azure.Identity; public void ConfigureServices(IServiceCollection services) { DefaultAzureCredential credential = new(); services.AddCosmosRepository( options =\u0026gt; { options.TokenCredential = credential; options.AccountEndpoint = \u0026#34;\u0026lt; account endpoint URI \u0026gt;\u0026#34;; options.ContainerId = \u0026#34;data-store\u0026#34;; options.DatabaseId = \u0026#34;samples\u0026#34;; }); }   The example above is using the DefaultAzureCredential object provided by the Azure Identity NuGet package, which provides seamless integration with Azure Active Directory. More information on this package is available here.\n"},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/2-container-config/","title":"Container Configuration","tags":[],"description":"","content":"// TODO: Add content here "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/3-item-types/etags/","title":"ETagItem","tags":[],"description":"","content":"Optimistic Concurrency Control with ETags The default repository now supports etags and will pass them when IItemWithEtag is implemented correctly or the base classes EtagItem or FullItem are used. The etag check is enforced on all updates when TItem is of the correct type. It can however be bypassed by setting the ignoreEtag optional parameter in the relevant async methods. The InMemory repository also supports OCC with Etags. The OptimisticCurrencyControl sample shows these features.\nGetting the new etag When creating a new object, if storing in memory, it is important to store the result from the create call to ensure you have the correct etag for future updated.\nFor example your code should look something like this:\nTItem currentItem = new TItem(...); currentItem = _repository.CreateAsync(currentItem); Sequential updates When doing sequential updates to the same item it is important to use the result from the update method (when OptimizeBandwith is false) or refetch the updated data each time (when OptimizeBandwith is true) otherwise the etag value will not be updated. The following code shows what to do in each case:\nOptimize Bandwith Off TItem currentItem = _repository.CreateAsync(itemConfig); currentItem = _repository.UpdateAsync(currentItem); currentItem = _repository.UpdateAsync(currentItem); Optimize Bandwith On TItem currentItem = _repository.CreateAsync(itemConfig); _repository.UpdateAsync(currentItem); currentItem = _repository.GetAsync(currentItem.Id); _repository.UpdateAsync(currentItem); currentItem = _repository.GetAsync(currentItem); currentItem = _repository.UpdateAsync(currentItem); Catching mismatched etag errors The following code shows how to catch the error when the etags do not match.\ntry { currentBankAccount = await repository.UpdateAsync(currentBankAccount); Console.WriteLine($\u0026#34;Updated bank account: {currentBankAccount}.\u0026#34;); } catch (CosmosException exception) when (exception.StatusCode == HttpStatusCode.PreconditionFailed) { Console.WriteLine(\u0026#34;Failed to update balance as the etags did not match.\u0026#34;); } Ignoring the etag The following code shows how to ignore the etag when doing an update.\nawait repository.UpdateAsync(currentBankAccount, ignoreEtag: true); Passing the etag to a patch update The following code shows how to pass the etag when doing a update to specific properties.\nawait repository.UpdateAsync(currentBankAccount.Id, builder =\u0026gt; builder.Replace(account =\u0026gt; account.Balance, currentBankAccount.Balance - 250), etag: currentBankAccount.Etag); "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/6-miscellaneous/healthchecks/","title":"Health Checks","tags":[],"description":"","content":"The IEvangelist.Azure.CosmosRepository.AspNetCore package adds support for AspNet Core Health Checks using the HealthChecks.CosmosDb package.\nSetup To configure Cosmos DB health checks:\nservices.AddHealthChecks().AddCosmosRepository(); By default, this will scan all of the assemblies in your solution to locate the container names for each of your IItem types. To refine this, and potentially reduce startup times, pass in the Assemblies containing your IItem types:\nservices.AddHealthChecks().AddCosmosRepository(assemblies: typeof(ExampleItem).Assembly); Alternatively, use the override to provide your own AzureCosmosDbHealthCheckOptions and configure the Containers to check:\nservices.AddHealthChecks().AddCosmosRepository(optionsFactory: sp =\u0026gt; new AzureCosmosDbHealthCheckOptions { DatabaseId = \u0026#34;my-database\u0026#34;, ContainerIds = new[] { \u0026#34;Container1\u0026#34;, \u0026#34;Container2\u0026#34; } }); Use optionsFactory: null to retain the default behaviour of the HealthChecks.CosmosDb package, and only call CosmosClient.ReadAccountAsync().\nservices.AddHealthChecks().AddCosmosRepository(optionsFactory: null); The Cosmos Repository Health package supports all of the existing functionality of Health Checks, such as failureStatus and tags, see the Microsoft documentation for configuration details.\nDon\u0026rsquo;t forget to map the health endpoint with:\napp.MapHealthChecks(\u0026#34;/healthz\u0026#34;); "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/6-miscellaneous/unique-keys/","title":"Unique Keys Policies","tags":[],"description":"","content":"Azure Cosmos DB provides the ability to define a set of properties on your JSON item that can be combined to form a unique key for a given partition. These are defined in the form of unique key policies. You can define multiple policies for the same partition key.\nExplanation of Unique Keys This is better explained with an example. Let\u0026rsquo;s for example say we are storing people in a Cosmos container. The people items are partitioned by by the county that they live in. So the partition key would be /county. Let\u0026rsquo;s say for example we can\u0026rsquo;t have a person with the same name and age in a county. This means that we need to build up a unique key based on the person\u0026rsquo;s name and age.\nSingle Key Policy Example In order to do this in the Azure Cosmos Repository you could define a class as below. This class decorates properties with attributes [UniqueKey] to define properties as unique keys.\nusing Microsoft.Azure.CosmosRepository; using Microsoft.Azure.CosmosRepository.Attributes; namespace Sample.Models public class Person : Item { [UniqueKey(propertyPath: \u0026#34;/firstName\u0026#34;)] public string FirstName { get; set; } [UniqueKey(propertyPath: \u0026#34;/age\u0026#34;)] public int Age { get; set; } public string County { get; set; } public string FavouriteColor { get; set; } protected override string GetPartitionKeyValue() =\u0026gt; County; public Person( string firstName, int age, string county, string favouriteColor) { FirstName = firstName; Age = age; County = county; FavouriteColor = favouriteColor; } } Adding to the above example the code below shows when a violation in this policy should occur should occur.\nIRepository\u0026lt;Person\u0026gt; repository = _serviceProvider.GetRequiredService\u0026lt;IRepository\u0026lt;Person\u0026gt;\u0026gt;(); Person bobInYorkshire = new Person(\u0026#34;bob\u0026#34;, 20, \u0026#34;Yorkshire\u0026#34;, \u0026#34;Blue\u0026#34;); repository.CreateAsync(bobInYorkshire); // This is in a different partition key range, so we can have another bob with the age of 20. Person bobInMerseyside = new Person(\u0026#34;bob\u0026#34;, 20, \u0026#34;Merseyside\u0026#34;, \u0026#34;Green\u0026#34;); repository.CreateAsync(bobInYorkshire); // This is bob with a different age in Yorkshire so this does not violate the policy. Person bobInYorkshireWhoIs22 = new Person(\u0026#34;bob\u0026#34;, 22, \u0026#34;Yorkshire\u0026#34;, \u0026#34;Red\u0026#34;); repository.CreateAsync(bobInYorkshireWhoIs22); try { //Adding another bob in Yorkshire violates the key.  Person bobInYorkshire = new Person(\u0026#34;bob\u0026#34;, 20, \u0026#34;Yorkshire\u0026#34;, \u0026#34;Yellow\u0026#34;); repository.CreateAsync(bobInYorkshire); } catch (CosmosException e) when (e.StatusCode is HttpStatusCode.Conflict) { //This is a violation of the key! }  The fact that these key policies are scoped to a single partition key range is very important! You can read more on this on the Official Cosmos DB Docs.\n Multiple Key Policies Example It is also possible in Cosmos DB to define multiple unique key policies for a single partition key range. It is possible to extend the above example by adding a policy that we cannot have people in the same county with the same favourite colour either. This can be implemented by adding another [UniqueKey] attribute onto the FavouriteColour property.\n Pay attention to the fact when defining the [UniqueKey] attributes we are grouping paths to different key names. This allows the policies to split. One for name and age and another for the favourite colour.\n using Microsoft.Azure.CosmosRepository; using Microsoft.Azure.CosmosRepository.Attributes; namespace Sample.Models public class Person : Item { [UniqueKey(keyName: \u0026#34;nameAndAgePolicyKeyName\u0026#34;, propertyPath: \u0026#34;/firstName\u0026#34;)] public string FirstName { get; set; } [UniqueKey(keyName: \u0026#34;nameAndAgePolicyKeyName\u0026#34;, propertyPath: \u0026#34;/age\u0026#34;)] public int Age { get; set; } public string County { get; set; } [UniqueKey(keyName: \u0026#34;favouriteColorPolicyKeyName\u0026#34;, propertyPath: \u0026#34;/favouriteColor\u0026#34;)] public string FavouriteColor { get; set; } protected override string GetPartitionKeyValue() =\u0026gt; County; public Person( string firstName, int age, string county, string favouriteColor) { FirstName = firstName; Age = age; County = county; FavouriteColor = favouriteColor; } } This defines two 3 unique keys split across 2 separate policies two paths are under the nameAndAgePolicyKeyName policy and one path is under the favouriteColorPolicyKeyName policy. See the example below when validation would occur in this example.\nIRepository\u0026lt;Person\u0026gt; repository = _serviceProvider.GetRequiredService\u0026lt;IRepository\u0026lt;Person\u0026gt;\u0026gt;(); Person bobInYorkshire = new Person(\u0026#34;bob\u0026#34;, 20, \u0026#34;Yorkshire\u0026#34;, \u0026#34;Blue\u0026#34;); repository.CreateAsync(bobInYorkshire); // This is in a different partition key range, so we can have another bob with the age of 20. Person bobInMerseyside = new Person(\u0026#34;bob\u0026#34;, 20, \u0026#34;Merseyside\u0026#34;, \u0026#34;Green\u0026#34;); repository.CreateAsync(bobInYorkshire); // This is bob with a different age in Yorkshire so this does not violate the policy. Person bobInYorkshireWhoIs22 = new Person(\u0026#34;bob\u0026#34;, 22, \u0026#34;Yorkshire\u0026#34;, \u0026#34;Red\u0026#34;); repository.CreateAsync(bobInYorkshireWhoIs22); try { //Fred does have a unique name and age, but he cannot also as Red as his favourite color.  Person fredInYorkshireWhoAlsoLikeRed = new Person(\u0026#34;fred\u0026#34;, 30, \u0026#34;Yorkshire\u0026#34;, \u0026#34;Red\u0026#34;); repository.CreateAsync(fredInYorkshireWhoAlsoLikeRed); } catch (CosmosException e) when (e.StatusCode is HttpStatusCode.Conflict) { //This is a violation of the key! } "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/3-item-types/","title":"Items","tags":[],"description":"","content":"Items The library provides a set of base types that can be used to tell the library that you want that model to be stored in Cosmos DB. These are know as Item types.\nThe simplest item types is the standard base Item. See an example of using Item below.\n See the rest of this section which covers the rest of the Item types.\n public class Product : Item { public string Name { get; set; } public string CategoryId { get; set; } public string PartitionKey { get; set; } public double Price { get; set; } public StockInformation Stock { get; set; } protected override string GetPartitionKeyValue() =\u0026gt; CategoryId; } "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/3-item-types/time-stamps/","title":"TimeStampedItem","tags":[],"description":"","content":"Time Stamped Item The last updated value is retrieved from the _ts property that Cosmos DB sets; as documented here. This property is deserialised and is available in the raw seconds (LastUpdatedTimeRaw) since epoch and a human readable format (LastUpdatedTimeUtc). Both the base classes FullItem and TimeStampedItem contain these properties.\nThe CreatedTimeUtc time property available in both the base classes FullItem and TimeStampedItem is set when CreateAsync is called on the repository. However, this property can be set prior to calling CreateAsync in which case it wont be overwritten; allowing you to set your own CreatedTimeUtc value. This does mean that when using existing date the CreatedTimeUtc property will be null.\n"},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/4-queries/","title":"Querying","tags":[],"description":"","content":"Querying Data in the Cosmos Repository The Cosmos Repository supports a rich set of methods for all sorts of query\u0026rsquo;s that you might need to run. This includes basic filters, paging using skip \u0026amp; take, paging uses Cosmos DB continuation tokens, as well as, a specification pattern implementation pattern to do even more with queries.\nBasics Querying The simplest way to get started with a query is to use the _repository.GetAsync\u0026lt;TITem\u0026gt; method this allows you to pass an expression used to filter your query.\npublic static class PeopleRepositoryExtensions { public static async Task\u0026lt;IEnumerable\u0026lt;Person\u0026gt;\u0026gt; GetPeopleOlderThan( this IRepository\u0026lt;Person\u0026gt; repository, DateTime date) { return await repository.GetAsync(p =\u0026gt; p.BirthDate \u0026gt; date); } public static async Task\u0026lt;IEnumerable\u0026lt;Person\u0026gt;\u0026gt; GetPeopleWithoutMiddleNames(this IRepository\u0026lt;Person\u0026gt; repository) { IEnumerable\u0026lt;Person\u0026gt; peopleWithoutMiddleNames = await repository.GetAsync(p =\u0026gt; p.MiddleName == null); return peopleWithoutMiddleNames; } }  The above example makes use of extensions methods. This can be a nice way to define queries using this library.\n Basic Paging There are 3 ways to page data in the library. Below shows the simplest one. It makes use of skip \u0026amp; take, or limit and offset.\npublic class PagingExamples { public async Task BasicPageAsync(IRepository\u0026lt;Person\u0026gt; repository) { double totalCharge = 0; IPageQueryResult\u0026lt;Person\u0026gt; page = await repository.PageAsync(pageNumber: 1, pageSize: 25); while (page.HasNextPage) { foreach (Person person in page.Items) { Console.WriteLine(person); } totalCharge += page.Charge; page = await repository.PageAsync(pageNumber: page.PageNumber.Value + 1, pageSize: 25); Console.WriteLine($\u0026#34;Get page {page.PageNumber} 25 results cost {page.Charge}\u0026#34;); } Console.WriteLine($\u0026#34;Total Charge {totalCharge} RU\u0026#39;s\u0026#34;); } }  This method if used on large data sets has an exponential RU charge. The further you read into the pages the more RUs this costs. Continuation token paging is preferred.\n Continuation Token Paging The second way to page data using the library is making use of Cosmos DBs continuation tokens. This offers a more cost effective way to page data in Cosmos DB. Just provide the continuation token back the .PageAsync method to pick up where you left off.\npublic class PagingExamples { public async Task BasicScrollingAsync(IRepository\u0026lt;Person\u0026gt; repository) { double totalCharge = 0; IPage\u0026lt;Person\u0026gt; page = await repository.PageAsync(pageSize: 25, continuationToken: null); foreach (Person person in page.Items) { Console.WriteLine(person); } totalCharge += page.Charge; Console.WriteLine($\u0026#34;First 25 results cost {page.Charge}\u0026#34;); page = await repository.PageAsync(pageSize: 25, continuationToken: page.Continuation); foreach (Person person in page.Items) { Console.WriteLine(person); } totalCharge += page.Charge; Console.WriteLine($\u0026#34;Second 25 results cost {page.Charge}\u0026#34;); page = await repository.PageAsync(pageSize: 50, continuationToken: page.Continuation); foreach (Person person in page.Items) { Console.WriteLine(person); } totalCharge += page.Charge; Console.WriteLine($\u0026#34;Last 50 results cost {page.Charge}\u0026#34;); Console.WriteLine($\u0026#34;Total Charge {totalCharge} RU\u0026#39;s\u0026#34;); } } Advanced Continuation Token Paging If you want to stream large amounts of data you can make use of the IAsyncEnumerable\u0026lt;T\u0026gt; type in C# to stream the pages to a consumer as they arrive.\npublic class ParcelRepository { private readonly IRepository\u0026lt;Parcel\u0026gt; _parcelCosmosRepository; public ParcelRepository(IRepository\u0026lt;Parcel\u0026gt; parcelCosmosRepository) =\u0026gt; _parcelCosmosRepository = parcelCosmosRepository; public async IAsyncEnumerable\u0026lt;IParcel\u0026gt; StreamParcelsWithDeliveryRegionId( string deliveryRegionId, int max, int chunkSize = 25, [EnumeratorCancellation] CancellationToken cancellationToken = default) { int collected = 0; bool hasMoreResults = true; string? token = null; Expression\u0026lt;Func\u0026lt;Parcel, bool\u0026gt;\u0026gt; expression = parcel =\u0026gt; parcel.PartitionKey == deliveryRegionId \u0026amp;\u0026amp; parcel.Status == ParcelStatus.Inducted; while (hasMoreResults \u0026amp;\u0026amp; collected \u0026lt; max) { var page = await _parcelCosmosRepository .PageAsync(expression, chunkSize, token, cancellationToken); token = page.Continuation; hasMoreResults = page.Continuation is not null; foreach (var item in page.Items) { if (collected \u0026lt; max) { yield return item; } collected++; } } } } "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/3-item-types/time-to-live/","title":"TimeToLiveItem","tags":[],"description":"","content":"Time To Live The time to live property can be set at both an item and container level. At a container level this can be done through the container options builder:\noptions.ContainerBuilder.Configure\u0026lt;BankAccount\u0026gt;( x =\u0026gt; x.WithContainerDefaultTimeToLive(TimeSpan.FromHours(2))); In the above example the container would have a default item lifespan of 2 hours. This can be overriden at the item level by using the TimeToLive property when correctly implemented. This is available through the FullItem and TimeToLiveItem base classes. The example below shows this been overriden so the item has a lifespan of 4 hours rather than the default of 2:\nBankAccount currentBankAccount = await repository.CreateAsync( new BankAccount() { Name = \u0026#34;Current Account\u0026#34;, Balance = 500.0, TimeToLive = TimeSpan.FromHours(4) }); If you didn\u0026rsquo;t want that specific item to ever expire the following code can be used:\nBankAccount currentBankAccount = await repository.CreateAsync( new BankAccount() { Name = \u0026#34;Current Account\u0026#34;, Balance = 500.0, TimeToLive = TimeSpan.FromSeconds(-1) }); The demo BankAccount class can be found in the OptimisticCurrencyControl sample and its implementation looks like the following:\nusing Microsoft.Azure.CosmosRepository; using Microsoft.Azure.CosmosRepository.Attributes; namespace OptimisticConcurrencyControl; [Container(\u0026#34;accounts\u0026#34;)] [PartitionKeyPath(\u0026#34;/id\u0026#34;)] public class BankAccount : FullItem { public string Name { get; set; } = string.Empty; public double Balance { get; set; } public void Withdraw(double amount) { if (Balance - amount \u0026lt; 0.0) throw new InvalidOperationException(\u0026#34;Cannot go overdrawn\u0026#34;); Balance -= amount; } public void Deposit(double amount) { Balance += amount; } public override string ToString() =\u0026gt; $\u0026#34;Account (Name = {Name}, Balance = {Balance}, Etag = {Etag})\u0026#34;; } This page goes into more detail about the various combinations.\n"},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/5-change-feed/","title":"Change Feed","tags":[],"description":"","content":"Change Feed Processing Overview Cosmos DB provides a mechanism for listening to changes in a container. This includes when an item is created or updated. This can be used for many scenarios such as:\n Creating events when items update. Replicating data into another Cosmos DB container. Perhaps with a different partitioning strategy. Replicating data into another storage medium, possibly SQL server.  The change feed does not currently support tracking the deletion of items. However, there are way you can do this with a soft delete. A soft delete can be done by setting a short TTL on the item.\n Listening to changes for an IItem It is possible to listen for changes on any IItem you have a container configured for in this library.\nConfiguring To start off you need to instruct the library that you would like to changes in a container for a given IItem. This is done via the IItemContainerBuilder which you can gain access to adding the repository into the IoC container. An example of this is shown below.\nWebApplicationBuilder builder = WebApplication.CreateBuilder(args); builder.Services.AddCosmosRepository(options =\u0026gt; { options.DatabaseId = \u0026#34;change-feed-demo\u0026#34;; options.ContainerPerItemType = true; options.ContainerBuilder.Configure\u0026lt;Book\u0026gt;(containerOptions =\u0026gt; { containerOptions.WithContainer(BookDemoConstants.Container); containerOptions.WithPartitionKey(BookDemoConstants.PartitionKey); //Listen to to the change feed  containerOptions.WithChangeFeedMonitoring(); }); } Change Feed Processors In order to process changes you need define a class that will process changes for a given IItem. This class is known as a processor and it must implement the IItemChangeFeedProcessor\u0026lt;TItem\u0026gt; interface. An example of a class implementing this interface is shown below.\npublic class BookChangeFeedProcessor : IItemChangeFeedProcessor\u0026lt;Book\u0026gt; { private readonly ILogger\u0026lt;BookChangeFeedProcessor\u0026gt; _logger; private readonly IRepository\u0026lt;BookByIdReference\u0026gt; _bookByIdReferenceRepository; public BookChangeFeedProcessor(ILogger\u0026lt;BookChangeFeedProcessor\u0026gt; logger, IRepository\u0026lt;BookByIdReference\u0026gt; bookByIdReferenceRepository) { _logger = logger; _bookByIdReferenceRepository = bookByIdReferenceRepository; } public async ValueTask HandleAsync(Book rating, CancellationToken cancellationToken) { _logger.LogInformation(\u0026#34;Change detected for book with ID: {BookId}\u0026#34;, rating.Id); if (!rating.HasBeenUpdated) { await _bookByIdReferenceRepository .CreateAsync(new BookByIdReference(rating.Id, rating.Category), cancellationToken); } _logger.LogInformation(\u0026#34;Processed change for book with ID: {BookId}\u0026#34;, rating.Id); } } "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/6-miscellaneous/","title":"Miscellaneous","tags":[],"description":"","content":"// TODO: Add content here "},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/7-major-release-notes/","title":"Major Release Notes","tags":[],"description":"","content":"Release 3.0.0 Nullable Reference Types The most significant change to the library is the support for nullable reference types. The API surface has been updated to fully support null reference types. This may introduce warnings to code that previously may not have had to be null aware. This will introduce compile errors in projects that have \u0026lt;TreatWarningsAsErrors\u0026gt;True\u0026lt;/TreatWarningsAsErrors\u0026gt; in a projects .csproj file.\nGetAsync method. The _repository.GetAsync(id, partitionKey) method was used to previously have a scenario where the API would return null.\nThis case was when the library read an item from cosmos successfully but the type field did not match that of the name of the class used. i.e. take the example below.\n{ \u0026#34;partitionKey\u0026#34;: \u0026#34;BookCategory\u0026#34;, \u0026#34;_etag\u0026#34;: \u0026#34;\\\u0026#34;3100b48c-0000-0700-0000-6219f58b0000\\\u0026#34;\u0026#34;, \u0026#34;timeToLive\u0026#34;: null, \u0026#34;createdTimeUtc\u0026#34;: \u0026#34;2022-02-26T09:40:27.000061Z\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;Engineering\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;BookCategory\u0026#34;, // \u0026lt;--------- TYPE Field  \u0026#34;_rid\u0026#34;: \u0026#34;vG1RAMQtoX4LAAAAAAAAAA==\u0026#34;, \u0026#34;_self\u0026#34;: \u0026#34;dbs/vG1RAA==/colls/vG1RAMQtoX4=/docs/vG1RAMQtoX4LAAAAAAAAAA==/\u0026#34;, \u0026#34;_attachments\u0026#34;: \u0026#34;attachments/\u0026#34;, \u0026#34;_ts\u0026#34;: 1645868427 } Notice the type field\u0026rsquo;s value is BookCategory if I was to use a repository let\u0026rsquo;s say with a class called Category the repository that you\u0026rsquo;d use via DI would look like IRepository\u0026lt;Category\u0026gt; when you made a read for this item the value of the type field from the above JSON does not match the name of the class. This would not previously result in an exception but return null to the caller.\nðŸ“£ The library now in this case throws an exception instead of returning null. The exception that will be thrown in the MissMatchedTypeDiscriminatorException code the previously checked for null will now have to catch this exception.\nOpt-in to receive total item counts when paging. Previously when using either of the paging operations provided by this library it would run a count query for every page request. This, however, can incur a large RU charge for large data sets. For this reason, we have chosen to make this now an opt-in feature. When calling either of the paging methods you will need to pass a bool to indicate you would like the count query to be run. See an example below.\n_dogRepository.PageAsync( d =\u0026gt; d.Breed == \u0026#34;cocker spaniel\u0026#34;, pageNumber, pageSize, returnTotal: true);  this returnTotal field defaults to false.\n ETagItem is now abstract This is a small change that makes the ETagItem class abstract.\n"},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/","title":"","tags":[],"description":"","content":"Azure Cosmos DB Repository .NET SDK This package wraps the NuGet: Microsoft.Azure.Cosmos package, exposing a simple dependency-injection enabled IRepository\u0026lt;T\u0026gt; interface.\nOverview The repository is responsible for all of the create, read, update, and delete (CRUD) operations on objects where T : Item. The Item type adds several properties, one which is a globally unique identifier defined as:\n[JsonProperty(\u0026#34;id\u0026#34;)] public string Id { get; set; } = Guid.NewGuid().ToString(); Additionally, a type property exists which indicates the subclass name (this is used for filtering implicitly on your behalf):\n[JsonProperty(\u0026#34;type\u0026#34;)] public string Type { get; set; } Finally, a partition key property is used internally to manage partitioning on your behalf. This can optionally be overridden on an item per item basis.\nðŸ“£ Azure Cosmos DB - Official Blog\nFor more information, see Customizing configuration sources.\nAuthenticating using an identity The Azure Cosmos DB .NET SDK also supports authentication using identities, which are considered superior from an audit and granularity of permissions perspective. Authenticating using a connection string essentially provides full access to perform operations within the data plane of your Cosmos DB Account. More information on the Azure control plane and data plane is available here.\nThis libary also supports authentication using an identity. To authenticate using an identity (User, Group, Application Registration, or Managed Identity) you will need to set the AccountEndpoint and TokenCredential options that are available on the RepositoryOptions class.\nIn a basic scenario, there are three steps that need to be completed:\n  If the identity that you would like to use, does not exist in Azure Active Directory, create it now.\n  Use the Azure CLI to assign the appropriate role to your identity at the desired scope. - In most cases, using the built-in roles will be sufficient. However, there is support for creating custom role definitions using the Azure CLI, you can read more on this here.\n  Configure your application using the AddCosmosRepository method in your Startup.cs file:\nusing Azure.Identity; public void ConfigureServices(IServiceCollection services) { DefaultAzureCredential credential = new(); services.AddCosmosRepository( options =\u0026gt; { options.TokenCredential = credential; options.AccountEndpoint = \u0026#34;\u0026lt; account endpoint URI \u0026gt;\u0026#34;; options.ContainerId = \u0026#34;data-store\u0026#34;; options.DatabaseId = \u0026#34;samples\u0026#34;; }); }   The example above is using the DefaultAzureCredential object provided by the Azure Identity NuGet package, which provides seamless integration with Azure Active Directory. More information on this package is available here.\nAdvanced partitioning strategy As a consumer of Azure Cosmos DB, you can choose how to partition your data. By default, this repository SDK will partition items using their Item.Id value as the /id partition in the storage container. However, you can override this default behavior by:\n Declaratively specifying the partition key path with PartitionKeyPathAttribute Override the Item.GetPartitionKeyValue() method Ensure the the property value of the composite or synthetic key is serialized to match the partition key path Set RepositoryOptions__ContainerPerItemType to true, to ensure that your item with explicit partitioning is correctly maintained  As an example, considering the following:\nusing Microsoft.Azure.CosmosRepository; using Microsoft.Azure.CosmosRepository.Attributes; using Newtonsoft.Json; using System; namespace Example { [PartitionKeyPath(\u0026#34;/synthetic\u0026#34;)] public class Person : Item { public string FirstName { get; set; } = null!; public string? MiddleName { get; set; } public string LastName { get; set; } = null!; [JsonProperty(\u0026#34;synthetic\u0026#34;)] public string SyntheticPartitionKey =\u0026gt; $\u0026#34;{FirstName}-{LastName}\u0026#34;; // Also known as a \u0026#34;composite key\u0026#34;.  protected override string GetPartitionKeyValue() =\u0026gt; SyntheticPartitionKey; } } In-memory Repository This library also includes an in-memory version of IRepository\u0026lt;T\u0026gt;. To use it swap out the normal services.AddCosmosRepository() for services.AddInMemoryCosmosRepository() and have all of your items stored in memory. This is a great tool for running integration tests using a package such as Microsoft.AspNetCore.Mvc.Testing, and not having to incur the cost of data stored in an Azure Cosmos DB resource.\nOptimistic Concurrency Control with Etags The default repository now supports etags and will pass them when IItemWithEtag is implemented correctly or the base classes EtagItem or FullItem are used. The etag check is enforced on all updates when TItem is of the correct type. It can however be bypassed by setting the ignoreEtag optional parameter in the relevant async methods. The InMemory repository also supports OCC with Etags. The OptimisticCurrencyControl sample shows these features.\nGetting the new etag When creating a new object, if storing in memory, it is important to store the result from the create call to ensure you have the correct etag for future updated.\nFor example your code should look something like this:\nTItem currentItem = new TItem(...); currentItem = _repository.CreateAsync(currentItem); Sequential updates When doing sequential updates to the same item it is important to use the result from the update method (when OptimizeBandwith is false) or refetch the updated data each time (when OptimizeBandwith is true) otherwise the etag value will not be updated. The following code shows what to do in each case:\nOptimize Bandwith Off TItem currentItem = _repository.CreateAsync(itemConfig); currentItem = _repository.UpdateAsync(currentItem); currentItem = _repository.UpdateAsync(currentItem); Optimize Bandwith On TItem currentItem = _repository.CreateAsync(itemConfig); _repository.UpdateAsync(currentItem); currentItem = _repository.GetAsync(currentItem.Id); _repository.UpdateAsync(currentItem); currentItem = _repository.GetAsync(currentItem); currentItem = _repository.UpdateAsync(currentItem); Catching mismatched etag errors The following code shows how to catch the error when the etags do not match.\ntry { currentBankAccount = await repository.UpdateAsync(currentBankAccount); Console.WriteLine($\u0026#34;Updated bank account: {currentBankAccount}.\u0026#34;); } catch (CosmosException exception) when (exception.StatusCode == HttpStatusCode.PreconditionFailed) { Console.WriteLine(\u0026#34;Failed to update balance as the etags did not match.\u0026#34;); } Ignoring the etag The following code shows how to ignore the etag when doing an update.\nawait repository.UpdateAsync(currentBankAccount, ignoreEtag: true); Passing the etag to a patch update The following code shows how to pass the etag when doing a update to specific properties.\nawait repository.UpdateAsync(currentBankAccount.Id, builder =\u0026gt; builder.Replace(account =\u0026gt; account.Balance, currentBankAccount.Balance - 250), etag: currentBankAccount.Etag); Time To Live The time to live property can be set at both an item and container level. At a container level this can be done through the container options builder:\noptions.ContainerBuilder.Configure\u0026lt;BankAccount\u0026gt;( x =\u0026gt; x.WithContainerDefaultTimeToLive(TimeSpan.FromHours(2))); In the above example the container would have a default item lifespan of 2 hours. This can be overriden at the item level by using the TimeToLive property when correctly implemented. This is available through the FullItem and TimeToLiveItem base classes. The example below shows this been overriden so the item has a lifespan of 4 hours rather than the default of 2:\nBankAccount currentBankAccount = await repository.CreateAsync( new BankAccount() { Name = \u0026#34;Current Account\u0026#34;, Balance = 500.0, TimeToLive = TimeSpan.FromHours(4) }); If you didn\u0026rsquo;t want that specific item to ever expire the following code can be used:\nBankAccount currentBankAccount = await repository.CreateAsync( new BankAccount() { Name = \u0026#34;Current Account\u0026#34;, Balance = 500.0, TimeToLive = TimeSpan.FromSeconds(-1) }); The demo BankAccount class can be found in the OptimisticCurrencyControl sample and its implementation looks like the following:\nusing Microsoft.Azure.CosmosRepository; using Microsoft.Azure.CosmosRepository.Attributes; namespace OptimisticConcurrencyControl; [Container(\u0026#34;accounts\u0026#34;)] [PartitionKeyPath(\u0026#34;/id\u0026#34;)] public class BankAccount : FullItem { public string Name { get; set; } = string.Empty; public double Balance { get; set; } public void Withdraw(double amount) { if (Balance - amount \u0026lt; 0.0) throw new InvalidOperationException(\u0026#34;Cannot go overdrawn\u0026#34;); Balance -= amount; } public void Deposit(double amount) { Balance += amount; } public override string ToString() =\u0026gt; $\u0026#34;Account (Name = {Name}, Balance = {Balance}, Etag = {Etag})\u0026#34;; } This page goes into more detail about the various combinations.\nCreated and Last Updated The last updated value is retrieved from the _ts property that Cosmos DB sets; as documented here. This property is deserialised and is available in the raw seconds (LastUpdatedTimeRaw) since epoch and a human readable format (LastUpdatedTimeUtc). Both the base classes FullItem and TimeStampedItem contain these properties.\nThe CreatedTimeUtc time property available in both the base classes FullItem and TimeStampedItem is set when CreateAsync is called on the repository. However, this property can be set prior to calling CreateAsync in which case it wont be overwritten; allowing you to set your own CreatedTimeUtc value. This does mean that when using existing date the CreatedTimeUtc property will be null.\nSamples Visit the Microsoft.Azure.CosmosRepository.Samples directory for samples on how to use the library with:\n Azure Functions Services Controllers (web apps) Paging  Deep-dive video \nDiscord Get extra support on our dedicated Discord channel.\n\n"},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://ievangelist.github.io/azure-cosmos-dotnet-repository/tags/","title":"Tags","tags":[],"description":"","content":""}]